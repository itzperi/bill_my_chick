-- Comprehensive diagnostic and fixes for salary entry and page rendering issues

-- 1) DIAGNOSTIC: Check if salaries table exists and has correct structure
DO $$ 
BEGIN
    -- Check if salaries table exists
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'salaries' AND table_schema = 'public') THEN
        RAISE NOTICE 'SALARIES TABLE MISSING - Creating public.salaries table';
        
        CREATE TABLE public.salaries (
            id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            business_id text NOT NULL,
            salary_date date NOT NULL,
            amount numeric(10,2) NOT NULL CHECK (amount >= 0),
            employee_id text,
            notes text,
            created_at timestamptz DEFAULT now(),
            updated_at timestamptz DEFAULT now(),
            CONSTRAINT salaries_business_id_not_empty CHECK (length(trim(business_id)) > 0)
        );
        
        -- Add indexes
        CREATE INDEX idx_salaries_business_date ON public.salaries (business_id, salary_date);
        CREATE INDEX idx_salaries_employee ON public.salaries (employee_id);
        
        -- Enable RLS
        ALTER TABLE public.salaries ENABLE ROW LEVEL SECURITY;
        
        -- Create policies
        CREATE POLICY IF NOT EXISTS salaries_select_policy ON public.salaries FOR SELECT USING (true);
        CREATE POLICY IF NOT EXISTS salaries_insert_policy ON public.salaries FOR INSERT WITH CHECK (true);
        CREATE POLICY IF NOT EXISTS salaries_update_policy ON public.salaries FOR UPDATE USING (true);
        CREATE POLICY IF NOT EXISTS salaries_delete_policy ON public.salaries FOR DELETE USING (true);
        
        RAISE NOTICE 'SALARIES TABLE CREATED SUCCESSFULLY';
    ELSE
        RAISE NOTICE 'SALARIES TABLE EXISTS - Checking structure';
        
        -- Check if required columns exist
        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'salaries' AND column_name = 'employee_id' AND table_schema = 'public') THEN
            ALTER TABLE public.salaries ADD COLUMN employee_id text;
            RAISE NOTICE 'Added employee_id column to salaries table';
        END IF;
        
        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'salaries' AND column_name = 'notes' AND table_schema = 'public') THEN
            ALTER TABLE public.salaries ADD COLUMN notes text;
            RAISE NOTICE 'Added notes column to salaries table';
        END IF;
        
        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'salaries' AND column_name = 'updated_at' AND table_schema = 'public') THEN
            ALTER TABLE public.salaries ADD COLUMN updated_at timestamptz DEFAULT now();
            RAISE NOTICE 'Added updated_at column to salaries table';
        END IF;
    END IF;
END $$;

-- 2) DIAGNOSTIC: Check if load_entries table exists and has correct structure
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'load_entries' AND table_schema = 'public') THEN
        RAISE NOTICE 'LOAD_ENTRIES TABLE MISSING - Creating public.load_entries table';
        
        CREATE TABLE public.load_entries (
            id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            business_id text NOT NULL,
            entry_date date NOT NULL,
            no_of_boxes integer NOT NULL CHECK (no_of_boxes >= 0),
            quantity_with_box numeric(10,2) NOT NULL CHECK (quantity_with_box >= 0),
            no_of_boxes_after integer NOT NULL CHECK (no_of_boxes_after >= 0),
            quantity_after_box numeric(10,2) NOT NULL CHECK (quantity_after_box >= 0),
            product_id bigint REFERENCES public.products(id) ON DELETE SET NULL,
            supplier_id bigint REFERENCES public.suppliers(id) ON DELETE SET NULL,
            created_at timestamptz DEFAULT now(),
            updated_at timestamptz DEFAULT now(),
            CONSTRAINT load_entries_business_id_not_empty CHECK (length(trim(business_id)) > 0)
        );
        
        -- Add indexes
        CREATE INDEX idx_load_entries_business_date ON public.load_entries (business_id, entry_date);
        CREATE INDEX idx_load_entries_product ON public.load_entries (product_id);
        CREATE INDEX idx_load_entries_supplier ON public.load_entries (supplier_id);
        
        -- Enable RLS
        ALTER TABLE public.load_entries ENABLE ROW LEVEL SECURITY;
        
        -- Create policies
        CREATE POLICY IF NOT EXISTS load_entries_select_policy ON public.load_entries FOR SELECT USING (true);
        CREATE POLICY IF NOT EXISTS load_entries_insert_policy ON public.load_entries FOR INSERT WITH CHECK (true);
        CREATE POLICY IF NOT EXISTS load_entries_update_policy ON public.load_entries FOR UPDATE USING (true);
        CREATE POLICY IF NOT EXISTS load_entries_delete_policy ON public.load_entries FOR DELETE USING (true);
        
        RAISE NOTICE 'LOAD_ENTRIES TABLE CREATED SUCCESSFULLY';
    ELSE
        RAISE NOTICE 'LOAD_ENTRIES TABLE EXISTS - Checking structure';
    END IF;
END $$;

-- 3) DIAGNOSTIC: Check if products table exists and has correct structure
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'products' AND table_schema = 'public') THEN
        RAISE NOTICE 'PRODUCTS TABLE MISSING - Creating public.products table';
        
        CREATE TABLE public.products (
            id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            business_id text NOT NULL,
            name text NOT NULL,
            created_at timestamptz DEFAULT now(),
            updated_at timestamptz DEFAULT now(),
            CONSTRAINT products_name_not_empty CHECK (length(trim(name)) > 0),
            CONSTRAINT products_business_id_not_empty CHECK (length(trim(business_id)) > 0)
        );
        
        -- Add indexes
        CREATE INDEX idx_products_business_name ON public.products (business_id, name);
        
        -- Enable RLS
        ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
        
        -- Create policies
        CREATE POLICY IF NOT EXISTS products_select_policy ON public.products FOR SELECT USING (true);
        CREATE POLICY IF NOT EXISTS products_insert_policy ON public.products FOR INSERT WITH CHECK (true);
        CREATE POLICY IF NOT EXISTS products_update_policy ON public.products FOR UPDATE USING (true);
        CREATE POLICY IF NOT EXISTS products_delete_policy ON public.products FOR DELETE USING (true);
        
        RAISE NOTICE 'PRODUCTS TABLE CREATED SUCCESSFULLY';
    ELSE
        RAISE NOTICE 'PRODUCTS TABLE EXISTS - Checking structure';
    END IF;
END $$;

-- 4) DIAGNOSTIC: Check if suppliers table exists and has correct structure
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'suppliers' AND table_schema = 'public') THEN
        RAISE NOTICE 'SUPPLIERS TABLE MISSING - Creating public.suppliers table';
        
        CREATE TABLE public.suppliers (
            id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            business_id text NOT NULL,
            name text NOT NULL,
            created_at timestamptz DEFAULT now(),
            updated_at timestamptz DEFAULT now(),
            CONSTRAINT suppliers_name_not_empty CHECK (length(trim(name)) > 0),
            CONSTRAINT suppliers_business_id_not_empty CHECK (length(trim(business_id)) > 0),
            UNIQUE (business_id, name)
        );
        
        -- Add indexes
        CREATE INDEX idx_suppliers_business_name ON public.suppliers (business_id, name);
        
        -- Enable RLS
        ALTER TABLE public.suppliers ENABLE ROW LEVEL SECURITY;
        
        -- Create policies
        CREATE POLICY IF NOT EXISTS suppliers_select_policy ON public.suppliers FOR SELECT USING (true);
        CREATE POLICY IF NOT EXISTS suppliers_insert_policy ON public.suppliers FOR INSERT WITH CHECK (true);
        CREATE POLICY IF NOT EXISTS suppliers_update_policy ON public.suppliers FOR UPDATE USING (true);
        CREATE POLICY IF NOT EXISTS suppliers_delete_policy ON public.suppliers FOR DELETE USING (true);
        
        RAISE NOTICE 'SUPPLIERS TABLE CREATED SUCCESSFULLY';
    ELSE
        RAISE NOTICE 'SUPPLIERS TABLE EXISTS - Checking structure';
    END IF;
END $$;

-- 5) DIAGNOSTIC: Check if inventory table exists
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'inventory' AND table_schema = 'public') THEN
        RAISE NOTICE 'INVENTORY TABLE MISSING - Creating public.inventory table';
        
        CREATE TABLE public.inventory (
            id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            business_id text NOT NULL,
            chicken_stock_kg numeric(10,2) DEFAULT 0 CHECK (chicken_stock_kg >= 0),
            created_at timestamptz DEFAULT now(),
            updated_at timestamptz DEFAULT now(),
            CONSTRAINT inventory_business_id_not_empty CHECK (length(trim(business_id)) > 0)
        );
        
        -- Add indexes
        CREATE INDEX idx_inventory_business ON public.inventory (business_id);
        
        -- Enable RLS
        ALTER TABLE public.inventory ENABLE ROW LEVEL SECURITY;
        
        -- Create policies
        CREATE POLICY IF NOT EXISTS inventory_select_policy ON public.inventory FOR SELECT USING (true);
        CREATE POLICY IF NOT EXISTS inventory_insert_policy ON public.inventory FOR INSERT WITH CHECK (true);
        CREATE POLICY IF NOT EXISTS inventory_update_policy ON public.inventory FOR UPDATE USING (true);
        CREATE POLICY IF NOT EXISTS inventory_delete_policy ON public.inventory FOR DELETE USING (true);
        
        RAISE NOTICE 'INVENTORY TABLE CREATED SUCCESSFULLY';
    ELSE
        RAISE NOTICE 'INVENTORY TABLE EXISTS';
    END IF;
END $$;

-- 6) Enhanced salary functions with comprehensive error handling
CREATE OR REPLACE FUNCTION public.safe_add_salary(
    p_business_id text,
    p_salary_date date,
    p_amount numeric,
    p_employee_id text DEFAULT NULL,
    p_notes text DEFAULT NULL
) RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
    v_salary_id bigint;
BEGIN
    -- Validate inputs
    IF p_business_id IS NULL OR trim(p_business_id) = '' THEN
        RAISE EXCEPTION 'Business ID is required';
    END IF;
    
    IF p_salary_date IS NULL THEN
        RAISE EXCEPTION 'Salary date is required';
    END IF;
    
    IF p_amount IS NULL OR p_amount <= 0 THEN
        RAISE EXCEPTION 'Salary amount must be greater than 0';
    END IF;
    
    -- Insert salary entry
    INSERT INTO public.salaries (business_id, salary_date, amount, employee_id, notes)
    VALUES (p_business_id, p_salary_date, p_amount, p_employee_id, p_notes)
    RETURNING id INTO v_salary_id;
    
    RETURN v_salary_id;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to add salary: %', SQLERRM;
END;
$$;

-- 7) Enhanced load entry function
CREATE OR REPLACE FUNCTION public.safe_add_load_entry(
    p_business_id text,
    p_entry_date date,
    p_no_of_boxes integer,
    p_quantity_with_box numeric,
    p_no_of_boxes_after integer,
    p_quantity_after_box numeric,
    p_product_id bigint DEFAULT NULL,
    p_supplier_id bigint DEFAULT NULL
) RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
    v_entry_id bigint;
BEGIN
    -- Validate inputs
    IF p_business_id IS NULL OR trim(p_business_id) = '' THEN
        RAISE EXCEPTION 'Business ID is required';
    END IF;
    
    IF p_entry_date IS NULL THEN
        RAISE EXCEPTION 'Entry date is required';
    END IF;
    
    IF p_no_of_boxes IS NULL OR p_no_of_boxes < 0 THEN
        RAISE EXCEPTION 'Number of boxes must be non-negative';
    END IF;
    
    IF p_quantity_with_box IS NULL OR p_quantity_with_box < 0 THEN
        RAISE EXCEPTION 'Quantity with box must be non-negative';
    END IF;
    
    IF p_no_of_boxes_after IS NULL OR p_no_of_boxes_after < 0 THEN
        RAISE EXCEPTION 'Number of boxes after must be non-negative';
    END IF;
    
    IF p_quantity_after_box IS NULL OR p_quantity_after_box < 0 THEN
        RAISE EXCEPTION 'Quantity after box must be non-negative';
    END IF;
    
    -- Insert load entry
    INSERT INTO public.load_entries (
        business_id, entry_date, no_of_boxes, quantity_with_box,
        no_of_boxes_after, quantity_after_box, product_id, supplier_id
    )
    VALUES (
        p_business_id, p_entry_date, p_no_of_boxes, p_quantity_with_box,
        p_no_of_boxes_after, p_quantity_after_box, p_product_id, p_supplier_id
    )
    RETURNING id INTO v_entry_id;
    
    RETURN v_entry_id;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to add load entry: %', SQLERRM;
END;
$$;

-- 8) Update triggers for all tables
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;

-- Apply update triggers
DROP TRIGGER IF EXISTS trg_salaries_updated_at ON public.salaries;
CREATE TRIGGER trg_salaries_updated_at
    BEFORE UPDATE ON public.salaries
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS trg_load_entries_updated_at ON public.load_entries;
CREATE TRIGGER trg_load_entries_updated_at
    BEFORE UPDATE ON public.load_entries
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS trg_products_updated_at ON public.products;
CREATE TRIGGER trg_products_updated_at
    BEFORE UPDATE ON public.products
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS trg_suppliers_updated_at ON public.suppliers;
CREATE TRIGGER trg_suppliers_updated_at
    BEFORE UPDATE ON public.suppliers
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS trg_inventory_updated_at ON public.inventory;
CREATE TRIGGER trg_inventory_updated_at
    BEFORE UPDATE ON public.inventory
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- 9) Diagnostic function to check table health
CREATE OR REPLACE FUNCTION public.diagnose_table_health()
RETURNS TABLE (
    table_name text,
    exists boolean,
    row_count bigint,
    has_data boolean
)
LANGUAGE plpgsql
AS $$
BEGIN
    -- Check salaries table
    RETURN QUERY
    SELECT 
        'salaries'::text as table_name,
        EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name = 'salaries' AND table_schema = 'public') as exists,
        COALESCE((SELECT COUNT(*) FROM public.salaries), 0) as row_count,
        (SELECT COUNT(*) > 0 FROM public.salaries) as has_data;
    
    -- Check load_entries table
    RETURN QUERY
    SELECT 
        'load_entries'::text as table_name,
        EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name = 'load_entries' AND table_schema = 'public') as exists,
        COALESCE((SELECT COUNT(*) FROM public.load_entries), 0) as row_count,
        (SELECT COUNT(*) > 0 FROM public.load_entries) as has_data;
    
    -- Check products table
    RETURN QUERY
    SELECT 
        'products'::text as table_name,
        EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name = 'products' AND table_schema = 'public') as exists,
        COALESCE((SELECT COUNT(*) FROM public.products), 0) as row_count,
        (SELECT COUNT(*) > 0 FROM public.products) as has_data;
    
    -- Check suppliers table
    RETURN QUERY
    SELECT 
        'suppliers'::text as table_name,
        EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name = 'suppliers' AND table_schema = 'public') as exists,
        COALESCE((SELECT COUNT(*) FROM public.suppliers), 0) as row_count,
        (SELECT COUNT(*) > 0 FROM public.suppliers) as has_data;
    
    -- Check inventory table
    RETURN QUERY
    SELECT 
        'inventory'::text as table_name,
        EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name = 'inventory' AND table_schema = 'public') as exists,
        COALESCE((SELECT COUNT(*) FROM public.inventory), 0) as row_count,
        (SELECT COUNT(*) > 0 FROM public.inventory) as has_data;
END;
$$;

-- 10) Final diagnostic report
DO $$
DECLARE
    rec RECORD;
BEGIN
    RAISE NOTICE '=== DATABASE DIAGNOSTIC REPORT ===';
    
    FOR rec IN SELECT * FROM public.diagnose_table_health() LOOP
        RAISE NOTICE 'Table: % | Exists: % | Rows: % | Has Data: %', 
            rec.table_name, rec.exists, rec.row_count, rec.has_data;
    END LOOP;
    
    RAISE NOTICE '=== DIAGNOSTIC COMPLETE ===';
END $$;
